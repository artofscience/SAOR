## Imports
import numpy as np
from ApproximationSchemes.NonMixed.Approx import Approximation


## MMA Approximation class
class CONLIN(Approximation):

    ## Constructor of class
    def __init__(self, n, m, xmin, xmax, **kwargs):
        Approximation.__init__(self, n, m, xmin, xmax)          # let parent class handle the common things
        self.name = 'CONLIN'
        self.P_test = np.zeros((self.m + 1, self.n))

    ## Define intermediate vars for MMA: y = T_inv(x)
    def _set_y(self, x):
        y = np.empty((self.n, self.m + 1))
        for j in range(0, self.m + 1):
            y[self.dg[j, :] >= 0, j] = x[self.dg[j, :] >= 0]
            y[self.dg[j, :] < 0, j] = (1 / x)[self.dg[j, :] < 0]
        return y

    ## Define derivatives intermediate vars for linear: dy/dx = dT_inv(x)/dx
    def _set_dydx(self, x):
        dy = np.empty((self.n, self.m + 1))
        for j in range(0, self.m + 1):
            dy[self.dg[j, :] >= 0, j] = np.ones(self.n)[self.dg[j, :] >= 0]
            dy[self.dg[j, :] < 0, j] = (-1 / x ** 2)[self.dg[j, :] < 0]
        return dy

    ## Define derivatives intermediate vars for linear: ddy/dx = ddT_inv(x)/dx
    def _set_ddydx(self, x):
        ddy = np.empty((self.n, self.m + 1))
        for j in range(0, self.m + 1):
            ddy[self.dg[j, :] >= 0, j] = np.zeros(self.n)[self.dg[j, :] >= 0]
            ddy[self.dg[j, :] < 0, j]  = (2 / x ** 3)[self.dg[j, :] < 0]
        return ddy

    ## Define chain rule term: y = T_inv(x) --> dT/dy = dx/dy
    def _set_dTdy(self):
        dTdy = np.empty((self.n, self.m + 1))
        for j in range(0, self.m + 1):
            dTdy[self.dg[j, :] >= 0, j] = np.ones(self.n)[self.dg[j, :] >= 0]
            dTdy[self.dg[j, :] < 0, j] = (-1 / self.y_k[:, j] ** 2)[self.dg[j, :] < 0]
        return dTdy

    ## Set P matrix for current iteration (P := P_ji + Q_ji of Svanberg's implementation)
    def _set_P(self):
        self.y_k = self._set_y(self.x)
        dTdy = self._set_dTdy()
        for j in range(0, self.m + 1):
            self.P[j, :] = self.dg[j, :] * dTdy[:, j]

    ## Set the bounds alpha, beta for all variables -x- for the sub-problem generated by MMA
    def _set_bounds(self):
        self.alpha = np.maximum.reduce([self.x - self.move_limit * self.dx, self.xmin])
        self.beta = np.minimum.reduce([self.x + self.move_limit * self.dx, self.xmax])

    ## Define some properties of the approximation scheme
    def _set_properties(self, **kwargs):
        self.properties.convex = kwargs.get('convex', None)
        self.properties.separable = kwargs.get('separable', None)
