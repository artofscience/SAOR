## Imports
import numpy as np
from ApproximationSchemes.NonMixed.Approx import Approximation


## Linear Approximation class
class Linear(Approximation):

    ## Constructor of class
    def __init__(self, n, m, xmin, xmax, **kwargs):
        Approximation.__init__(self, n, m, xmin, xmax)       # Let parent class handle the common arguments
        self.name = 'Linear'

        # New stuff
        self.y_k = np.empty((self.n, self.m + 1))  # intermediate vars
        self.P = np.empty((self.m + 1, self.n))  # P = max{dg/dx, 0} * dT/dy
        self.zo_term = np.empty(self.m + 1)  # r_j^(k) in Svanberg's paper

    # ## Define intermediate vars: x = T(y)
    # def T_of_y(self, y, j):
    #     x = y[:]
    #     return x

    ## Define intermediate vars: each row corresponds to a branch of T_inv(x)
    def _set_y(self, x):
        y = np.empty((self.n, self.m + 1))
        for j in range(0, self.m + 1):
            y[:, j] = x
        return y

    ## Define intermediate vars: each row corresponds to a branch of T_inv(x)
    def _set_dydx(self, x):
        dy = np.empty((self.n, self.m + 1))
        dy[:] = 1
        return dy

    ## Define intermediate vars: each row corresponds to a branch of T_inv(x)
    def _set_ddydx(self, x):
        ddy = np.empty((self.n, self.m + 1))
        ddy[:] = 0
        return ddy

    ## Define chain rule term: y = T_inv(x) --> dT/dy = dx/dy
    def _set_dTdy(self):
        dTdy = np.empty((self.n, self.m + 1))
        dTdy[:] = 1
        return dTdy

    ## Set approx.P matrices at current iteration: approx.P[:, :, 0] = P, approx.P[:, :, 1] = Q
    def _set_P(self):
        self.y_k = self._set_y(self.x)
        dTdy = self._set_dTdy()
        for j in range(0, self.m + 1):
            self.P[j, :] = self.dg[j, :] * dTdy[:, j]

    ## Set the bounds alpha, beta for all variables -x- for the sub-problem generated by Linear
    def _set_bounds(self):
        self.alpha = np.maximum.reduce([self.x - self.move_limit * self.dx, self.xmin])
        self.beta = np.minimum.reduce([self.x + self.move_limit * self.dx, self.xmax])

    ## Define some properties of the approximation scheme
    def _set_properties(self, **kwargs):
        self.properties.convex = kwargs.get('convex', None)
        self.properties.separable = kwargs.get('separable', None)
