## Imports
import numpy as np
from ApproximationSchemes.NonMixed.Approx import Approximation


## Linear Approximation class
class Linear(Approximation):

    ## Constructor of class
    def __init__(self, n, m, xmin, xmax, **kwargs):
        Approximation.__init__(self, n, m, xmin, xmax)       # Let parent class handle the common arguments
        self.name = 'Linear'
        self.y_k = np.empty((self.n, self.m + 1))   # intermediate vars, different for each response (for mixed schemes)
        self.P = np.empty((self.m + 1, self.n))     # dg/dx * dT/dy = dg/dx * dx/dy
        self.zo_term = np.empty(self.m + 1)         # Constant part of Taylor expansion to be computed only once

    ## Define intermediate vars: each row corresponds to a branch of T_inv(x)
    def _set_y(self, x):
        return x*np.ones((self.n, self.m+1), dtype=float)

    ## Define intermediate vars: each row corresponds to a branch of T_inv(x)
    def _set_dydx(self, x):
        return np.ones((self.n, self.m + 1), dtype=float)

    ## Define intermediate vars: each row corresponds to a branch of T_inv(x)
    def _set_ddydx(self, x):
        return np.zeros((self.n, self.m + 1), dtype=float)

    ## Define chain rule term: y = T_inv(x) --> dT/dy = dx/dy
    def _set_dTdy(self):
        return np.ones((self.n, self.m + 1), dtype=float)

    ## Set approx.P matrices at current iteration: approx.P[:, :, 0] = P, approx.P[:, :, 1] = Q
    def _set_P(self):
        self.y_k = self._set_y(self.x)
        dTdy = self._set_dTdy()
        for j in range(0, self.m + 1):
            self.P[j, :] = self.dg[j, :] * dTdy[:, j]

    ## Set the bounds alpha, beta for all variables -x- for the sub-problem generated by Linear
    def _set_bounds(self):
        self.alpha = np.maximum.reduce([self.x - self.move_limit * self.dx, self.xmin])
        self.beta = np.minimum.reduce([self.x + self.move_limit * self.dx, self.xmax])

    ## Define some properties of the approximation scheme
    def _set_properties(self, **kwargs):
        self.properties.convex = kwargs.get('convex', None)
        self.properties.separable = kwargs.get('separable', None)
