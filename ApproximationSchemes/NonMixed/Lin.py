## Imports
import numpy as np
from ApproximationSchemes.NonMixed.Approx import Approximation


## Linear Approximation class
class Linear(Approximation):

    ## Constructor of class
    def __init__(self, n, m, xmin, xmax, **kwargs):
        Approximation.__init__(self, n, m, xmin, xmax)       # Let parent class handle the common things
        self.name = 'Linear'

    ## Define intermediate vars for linear: y = T_inv(x) = x
    def _set_y(self, x):
        return x*np.ones((self.n, self.m+1), dtype=float)

    ## Define derivatives intermediate vars for linear: dy/dx = dT_inv(x)/dx = 1
    def _set_dydx(self, x):
        return np.ones((self.n, self.m + 1), dtype=float)

    ## Define derivatives intermediate vars for linear: ddy/dx = ddT_inv(x)/dx = 0
    def _set_ddydx(self, x):
        return np.zeros((self.n, self.m + 1), dtype=float)

    ## Define chain rule term: y = T_inv(x) --> dT/dy = dx/dy
    def _set_dTdy(self):
        return np.ones((self.n, self.m + 1), dtype=float)

    ## Define chain rule 2nd-order term: y = T_inv(x) --> d^2T/dy^2 = d^2x/dy^2
    def _set_ddTdy(self):
        return np.zeros((self.n, self.m + 1), dtype=float)

    ## Set the bounds alpha, beta for all variables -x- for the sub-problem generated by Linear
    def _set_bounds(self):
        self.alpha = np.maximum.reduce([self.x - self.move_limit * self.dx, self.xmin])
        self.beta = np.minimum.reduce([self.x + self.move_limit * self.dx, self.xmax])

    ## Define some properties of the approximation scheme
    def _set_properties(self, **kwargs):
        self.properties.convex = kwargs.get('convex', None)
        self.properties.separable = kwargs.get('separable', None)
